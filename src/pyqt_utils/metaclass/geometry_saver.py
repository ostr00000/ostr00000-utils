from typing import TypedDict

from PyQt5.QtWidgets import QDialog, QMainWindow, QWidget
from pyqt_utils.metaclass.geometry_save_dec import (
    SettingProtocol,
    loadGeometryDecFac,
    loadStateDecFac,
    saveGeometryDecFac,
    saveStateDecFac,
)
from pyqt_utils.metaclass.qt_meta import AbcQtMeta


class KlassDict(TypedDict, total=False):
    klass: type


class GeometrySaverMeta(AbcQtMeta):
    def __new__(
        cls,
        name,
        bases,
        namespace,
        settings: SettingProtocol = None,
        saveName: str = "geometry",
    ):
        if not isinstance(settings, SettingProtocol):
            msg = "setting argument must be provided when class is created"
            raise TypeError(msg)
        cls._checkBases(bases, name)

        klassDict: KlassDict = {}
        facAttr = {'key': f'geometry/{saveName}', 'settings': settings}

        # normal init
        __init__ = cls._extractOrCreate(namespace, klassDict, '__init__')
        namespace['__init__'] = loadGeometryDecFac(**facAttr)(__init__)

        # normal close
        closeEvent = cls._extractOrCreate(namespace, klassDict, 'closeEvent')
        namespace['closeEvent'] = saveGeometryDecFac(**facAttr)(closeEvent)

        # dialog close
        if any(issubclass(base, QDialog) for base in bases):
            done = cls._extractOrCreate(namespace, klassDict, 'done')
            namespace['done'] = saveGeometryDecFac(**facAttr)(done)

        # main window: init + close
        if any(issubclass(base, QMainWindow) for base in bases):
            facAttr['key'] = f'state/{saveName}'
            namespace['__init__'] = loadStateDecFac(**facAttr)(namespace['__init__'])
            namespace['closeEvent'] = saveStateDecFac(**facAttr)(
                namespace['closeEvent']
            )

        createdClass = super().__new__(cls, name, bases, namespace)
        klassDict['klass'] = createdClass
        return createdClass

    @classmethod
    def _checkBases(cls, bases: tuple[type], name: str):
        if not any(issubclass(base, QWidget) for base in bases):
            msg = (
                f"Wrong bases class {','.join(str(b) for b in bases)} "
                f"- cannot use save position decorator on {name}"
            )
            raise TypeError(msg)

    @classmethod
    def _extractOrCreate(cls, namespace: dict, klassDict: KlassDict, functionName: str):
        if orgFun := namespace.get(functionName):
            return orgFun

        def generated(self, *args, **kwargs):
            kl = klassDict.get('klass')
            if kl is None:
                msg = "Cannot use generated method when klass is not created yet!"
                raise KeyError(msg)

            sup = super(kl, self)  # pyright: ignore[reportArgumentType]
            fun = getattr(sup, functionName)
            return fun(*args, **kwargs)

        generated.__doc__ = f"Function `{functionName}` generated by {cls.__name__}."
        return generated
